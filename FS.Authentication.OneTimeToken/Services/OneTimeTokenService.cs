using FS.Authentication.OneTimeToken.Abstractions.Interfaces;
using FS.Authentication.OneTimeToken.Abstractions.Models;
using FS.Authentication.OneTimeToken.Models;
using Microsoft.Extensions.Options;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Security.Claims;

namespace FS.Authentication.OneTimeToken.Services;

/// <summary>
/// Service to create and validate one time tokens.
/// </summary>
public class OneTimeTokenService : IOneTimeTokenService
{
    private readonly IOptionsMonitor<OneTimeTokenOptions> _options;

    internal ConcurrentDictionary<string, Token> Tokens { get; }

    /// <summary>
    /// Initializes a new instance of the <see cref="OneTimeTokenService"/> class.
    /// </summary>
    /// <param name="options">Options for controlling the operation.</param>
    /// <autogeneratedoc />
    public OneTimeTokenService(IOptionsMonitor<OneTimeTokenOptions> options)
    {
        Tokens = new ConcurrentDictionary<string, Token>();
        _options = options;
    }

    /// <inheritdoc />
    public string CreateToken()
        => CreateToken(_options.CurrentValue.DefaultExpireTime, Enumerable.Empty<Claim>());

    /// <inheritdoc />
    public string CreateToken(TimeSpan expiresIn)
        => CreateToken(expiresIn, Enumerable.Empty<Claim>());

    /// <inheritdoc />
    public string CreateToken(IEnumerable<Claim> claims)
        => CreateToken(_options.CurrentValue.DefaultExpireTime, claims);

    /// <inheritdoc />
    public string CreateToken(TimeSpan expiresIn, IEnumerable<Claim> claims)
    {
        RemoveExpiredTokens();

        if (expiresIn.Ticks < 0)
            throw new ArgumentOutOfRangeException(nameof(expiresIn), expiresIn, "Must be positive.");

        var now = _options.CurrentValue.Now();
        var expiresUtc = expiresIn != TimeSpan.MaxValue
            ? now.Add(expiresIn)
            : DateTime.MaxValue;

        var token = new Token { Key = Guid.NewGuid().ToString(), Expires = expiresUtc, Claims = claims };
        Tokens.TryAdd(token.Key, token);
        return token.Key;
    }

    /// <inheritdoc />
    public string CreateToken(params Claim[] claims)
        => CreateToken(_options.CurrentValue.DefaultExpireTime, (IEnumerable<Claim>)claims);

    /// <inheritdoc />
    public string CreateToken(TimeSpan expiresIn, params Claim[] claims)
        => CreateToken(expiresIn, (IEnumerable<Claim>)claims);

    /// <inheritdoc />
    [Obsolete(Messages.CREATE_TOKEN_WITH_CLAIMS)]
    public string CreateToken(params string[] roles)
        => CreateToken(_options.CurrentValue.DefaultExpireTime, roles.Select(role => new Claim(ClaimTypes.Role, role)));

    /// <inheritdoc />
    [Obsolete(Messages.CREATE_TOKEN_WITH_CLAIMS)]
    public string CreateToken(TimeSpan expiresIn, params string[] roles)
        => CreateToken(expiresIn, roles.Select(role => new Claim(ClaimTypes.Role, role)));

    /// <inheritdoc />
    public TokenValidationResult ValidateToken(string token)
    {
        RemoveExpiredTokens();

        if (!Tokens.TryRemove(token, out var oneTimeToken))
            return TokenValidationResult.Failed();

        var now = _options.CurrentValue.Now();
        if (now > oneTimeToken.Expires)
            return TokenValidationResult.Failed();

        return TokenValidationResult.Success(oneTimeToken.Claims);
    }

    private void RemoveExpiredTokens()
    {
        var now = _options.CurrentValue.Now();
        var expiredTokens = Tokens.Values.Where(x => x.Expires < now);
        foreach (var expiredToken in expiredTokens)
            Tokens.Remove(expiredToken.Key, out _);
    }

    internal class Token
    {
        public string Key { get; init; }
        public DateTime Expires { get; init; }
        public IEnumerable<Claim> Claims { get; set; }
    }
}