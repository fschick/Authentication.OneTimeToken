using FS.Authentication.OneTimeToken.Abstractions.Interfaces;
using FS.Authentication.OneTimeToken.Abstractions.Models;
using FS.Authentication.OneTimeToken.Models;
using Microsoft.Extensions.Options;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Security.Claims;

namespace FS.Authentication.OneTimeToken.Services;

/// <summary>
/// Service to create and validate one time tokens.
/// </summary>
public class OneTimeTokenService : IOneTimeTokenService
{
    private readonly ConcurrentDictionary<string, Token> _tokens;
    private readonly IOptionsMonitor<OneTimeTokenOptions> _options;

    internal ConcurrentDictionary<string, Token> Tokens => _tokens;

    /// <summary>
    /// Initializes a new instance of the <see cref="OneTimeTokenService"/> class.
    /// </summary>
    /// <param name="options">Options for controlling the operation.</param>
    /// <autogeneratedoc />
    public OneTimeTokenService(IOptionsMonitor<OneTimeTokenOptions> options)
    {
        _tokens = new ConcurrentDictionary<string, Token>();
        _options = options;
    }

    /// <inheritdoc />
    public TokenValidationResult ValidateToken(string token)
    {
        RemoveExpiredTokens();

        if (!_tokens.TryRemove(token, out var oneTimeToken))
            return TokenValidationResult.Failed();

        var now = _options.CurrentValue.Now();
        if (now > oneTimeToken.Expires)
            return TokenValidationResult.Failed();

        return TokenValidationResult.Success(oneTimeToken.Claims);
    }

    /// <inheritdoc />
    public string CreateToken()
        => CreateToken(null, (Claim[])null);

    /// <inheritdoc />
    public string CreateToken(TimeSpan expiresIn)
        => CreateToken(expiresIn, (Claim[])null);

    /// <inheritdoc />
    [Obsolete(Messages.CREATE_TOKEN_WITH_CLAIMS)]
    public string CreateToken(params string[] roles)
        => CreateToken(null, roles);

    /// <inheritdoc />
    [Obsolete(Messages.CREATE_TOKEN_WITH_CLAIMS)]
    public string CreateToken(TimeSpan? expiresIn = null, params string[] roles)
        => CreateToken(null, roles.Select(role => new Claim(ClaimTypes.Role, role)).ToArray());

    /// <inheritdoc />
    public string CreateToken(params Claim[] claims)
        => CreateToken(null, claims);

    /// <inheritdoc />
    public string CreateToken(TimeSpan? expiresIn = null, params Claim[] claims)
    {
        RemoveExpiredTokens();

        var now = _options.CurrentValue.Now();
        var expiresTimeSpan = expiresIn ?? _options.CurrentValue.DefaultExpireTime;

        if (expiresTimeSpan.Ticks < 0)
            throw new ArgumentOutOfRangeException(nameof(expiresIn), expiresIn, "Must be positive.");

        var expiresUtc = expiresTimeSpan != TimeSpan.MaxValue
            ? now.Add(expiresTimeSpan)
            : DateTime.MaxValue;

        var token = new Token { Key = Guid.NewGuid().ToString(), Expires = expiresUtc, Claims = claims };
        _tokens.TryAdd(token.Key, token);
        return token.Key;
    }

    private void RemoveExpiredTokens()
    {
        var now = _options.CurrentValue.Now();
        var expiredTokens = _tokens.Values.Where(x => x.Expires < now);
        foreach (var expiredToken in expiredTokens)
            _tokens.Remove(expiredToken.Key, out _);
    }

    internal class Token
    {
        public string Key { get; init; }
        public DateTime Expires { get; init; }
        public Claim[] Claims { get; set; }
    }
}